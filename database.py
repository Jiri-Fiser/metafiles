from typing import Optional
from enum import IntEnum

from sqlalchemy import (
    create_engine,
    Text,
    LargeBinary,
    JSON,
    Enum,
    DateTime,
    func,
    UniqueConstraint,
    text
)
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, Session
from datetime import datetime
import logging

class ReprMixin:
    # Seznam dvojic (datový typ, formátovací funkce)
    __repr_formatters__ = [
        (datetime, lambda dt: dt.strftime("%Y-%m-%d %H:%M")),  # bez sekund
        (bytes, lambda b: b.hex())  # hexadecimální výpis
    ]

    def __repr__(self):
        values = []
        for column in self.__table__.columns:
            value = getattr(self, column.name)
            for data_type, formatter in self.__repr_formatters__:
                if isinstance(value, data_type):
                    value = formatter(value)
                    break
            values.append(f"{column.name}={value!r}")
        return f"<{self.__class__.__name__}({', '.join(values)})>"



class ConflictError(Exception):
    """
    Raised when a record with the same primary key exists but has different content.
    Carries both the desired (new) FileRecord instance and the existing conflicting one.
    """
    def __init__(self, new_record: "FileRecord", existing_record: "FileRecord"):
        self.new_record = new_record
        self.existing_record = existing_record
        super().__init__("Conflict: Record with same PK exists but differs.")


class Base(DeclarativeBase):
    pass


# --- Výčtový typ pro úrovně logování ---
class LogLevel(IntEnum):
    Info = 0
    Warning = 1
    Error = 2


# --- Entitní třída ---
class LogRecord(Base):
    __tablename__ = "log_records"

    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    log_time: Mapped[Optional[str]] = mapped_column(
        DateTime,
        nullable=False,
        server_default=text("CURRENT_TIMESTAMP")
    )
    level: Mapped[LogLevel] = mapped_column(
        Enum(LogLevel, native_enum=False, name="log_level"),
        nullable=False
    )
    description: Mapped[str] = mapped_column(Text, nullable=False)
    filename: Mapped[str] = mapped_column(Text, nullable=False)
    old_value: Mapped[Optional[str]] = mapped_column(Text)
    new_value: Mapped[Optional[str]] = mapped_column(Text)
    detail: Mapped[Optional[str]] = mapped_column(Text)

    @staticmethod
    def write_log(
        session: Session,
        level: LogLevel,
        description: str,
        filename: str,
        *,
        old_value: Optional[str] = None,
        new_value: Optional[str] = None,
        detail: Optional[str] = None
    ) -> 'LogRecord':
        """
        Inserts a new log record. Timestamp is generated by the database server.
        """
        record = LogRecord(
            level=level,
            description=description,
            filename=filename,
            old_value=old_value,
            new_value=new_value,
            detail=detail
        )
        session.add(record)
        return record


class FileRecord(ReprMixin, Base):
    __tablename__ = "file_records"
    __table_args__ = (UniqueConstraint("local_path"),)

    ark_base_name: Mapped[str] = mapped_column(Text, primary_key=True)
    local_path: Mapped[str] = mapped_column(Text, nullable=False)
    digest: Mapped[bytes] = mapped_column(LargeBinary, nullable=False)
    metadata_data: Mapped[dict] = mapped_column(JSON, nullable=False)
    linkdata: Mapped[dict] = mapped_column(JSON, nullable=False)
    created: Mapped[datetime] = mapped_column(DateTime, default=func.now(), nullable=False)
    updated: Mapped[datetime] = mapped_column(DateTime, default=func.now(), onupdate=func.now(), nullable=False)

    @classmethod
    def update(cls, session: Session, record: 'FileRecord') -> None:
        ark_base_name = record.ark_base_name
        assert session.get(cls, ark_base_name) is not None, "Unexpected insert, update is expected."
        session.merge(record)
        session.commit()

    @classmethod
    def insert_if_new_or_identical(cls, session: Session, new_obj: 'FileRecord') -> "FileRecord":
        """
        Insert a new record if it does not exist.
        If an identical record already exists, do nothing.
        If a conflicting record exists (same PK but different values), raise ConflictError.

        Args:
            session (Session): SQLAlchemy session.
            data (dict): Dictionary of all required fields (must include `ark_base_name`).

        Returns:
            FileRecord: The inserted or existing record.

        Raises:
            ConflictError: if a record with the same primary key exists but differs.
        """
        ark_base_name = new_obj.ark_base_name
        with session.begin():
            existing = session.get(cls, ark_base_name)

            if existing is None:
                session.add(new_obj)
                LogRecord.write_log(session, LogLevel.Info, "file added",
                                    new_obj.local_path)
                logging.info(f"insert record: {new_obj}")
                return new_obj
            else:
                fields_to_compare = ["local_path", "digest", "metadata", "linkdata"]
                is_identical = all(
                    getattr(existing, field) == getattr(new_obj, field)
                    for field in fields_to_compare
                )

                if is_identical:
                    return existing
                else:
                    raise ConflictError(new_obj, existing)

def initialize_database(db_url: str) -> Session:
    """
    Initializes the database and creates the file_records table if it doesn't already exist.

    Args:
        db_url (str): SQLAlchemy database URL (defaults to local SQLite file).
    """
    engine = create_engine(db_url, echo=False, future=True)
    Base.metadata.create_all(engine)
    return Session(engine)

